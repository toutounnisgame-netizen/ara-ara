"""
GameSession V3.0 - CONSOLID√â OPTIMIS√â
Toutes les corrections et am√©liorations int√©gr√©es dans un fichier unique
"""
from core.system import SystemManager
from core.entity import Entity
from entities.player import PlayerCharacter
from entities.npc import NPCMale
from entities.environment import Environment
from entities.game_state import GameState
from utils.performance import PerformanceMonitor
from utils.logger import GameLogger
from systems.stats_system import StatsSystem
from systems.clothing_system import ClothingSystem
from systems.ai_system import AISystem
from systems.dialogue_system import DialogueSystem
from systems.input_system import InputSystem
from typing import Dict, List, Any, Optional
import time
import json

class GameSession:
    """
    Orchestrateur principal V3.0 - CONSOLID√â OPTIMIS√â
    Int√®gre toutes les corrections et am√©liorations
    """

    def __init__(self, config_path: str = "assets/config/settings.json"):
        # Logging et monitoring
        self.logger = GameLogger()
        self.performance_monitor = PerformanceMonitor()

        # Configuration
        self.config = self._load_config(config_path)

        # Entities principales
        self.player = PlayerCharacter("Joueuse")
        self.npc = NPCMale()
        self.game_state = GameState()

        # Environments avec propri√©t√©s escalation
        self.environments = {
            "bar": Environment("bar", "Le Moonlight - Bar Lounge", 
                             privacy_level=0.2, escape_difficulty=0.1),
            "voiture": Environment("voiture", "Dans sa voiture", 
                                 privacy_level=0.6, escape_difficulty=0.3),
            "salon": Environment("salon", "Son appartement - Salon", 
                               privacy_level=0.8, escape_difficulty=0.5),
            "chambre": Environment("chambre", "Sa chambre", 
                                 privacy_level=1.0, escape_difficulty=0.7)
        }
        self.current_environment = self.environments["bar"]

        # Liste compl√®te des entities
        self.entities = [
            self.player,
            self.npc,
            self.game_state,
            *self.environments.values()
        ]

        # Systems manager
        self.system_manager = SystemManager()
        self._setup_systems()

        # √âtat du game loop
        self.running = False
        self.paused = False
        self.last_update_time = 0.0

        # Cache pour optimisation
        self._input_cache = {}
        self._response_cache = {}

        # Initialisation
        self.logger.info(f"GameSession V3.0 initialis√©e avec {len(self.entities)} entities")
        self.logger.info(f"Systems actifs: {len(self.system_manager)}")

    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Charge la configuration depuis JSON"""
        default_config = {
            "game": {
                "title": "Strip, Sex & Seduce",
                "version": "3.0.0",
                "debug_mode": False
            },
            "performance": {
                "max_memory_mb": 5,
                "target_response_ms": 50,
                "cache_enabled": True
            },
            "gameplay": {
                "difficulty": "normal",
                "auto_save": False,
                "auto_escalation": True
            },
            "interface": {
                "show_stats": True,
                "show_help_hints": True,
                "rich_dialogues": True
            }
        }

        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
                # Merge avec config par d√©faut
                for section in default_config:
                    if section not in config:
                        config[section] = default_config[section]
                    else:
                        for key, value in default_config[section].items():
                            if key not in config[section]:
                                config[section][key] = value
                return config
        except (FileNotFoundError, json.JSONDecodeError) as e:
            self.logger.warning(f"Erreur chargement config: {e}, utilisation config par d√©faut")
            return default_config

    def _setup_systems(self):
        """Configure tous les systems avec priorit√©s optimis√©es"""
        # System de stats (priorit√© haute - doit s'ex√©cuter en premier)
        stats_system = StatsSystem()
        self.system_manager.add_system(stats_system, priority=1)

        # System de v√™tements (d√©pend des stats)
        clothing_system = ClothingSystem()
        self.system_manager.add_system(clothing_system, priority=2)

        # System IA (analyse l'√©tat pour d√©cider actions)
        ai_system = AISystem()
        self.system_manager.add_system(ai_system, priority=3)

        # System dialogues CORRIG√â (g√©n√®re textes selon √©tat)
        dialogue_system = DialogueSystem()
        self.system_manager.add_system(dialogue_system, priority=4)

        # System input (traite les entr√©es utilisateur)
        input_system = InputSystem()
        self.system_manager.add_system(input_system, priority=5)

        self.logger.info("Systems V3.0 configur√©s avec priorit√©s optimis√©es")

    def run_game_loop(self):
        """Lance le game loop principal optimis√©"""
        self.logger.info("D√©marrage game loop principal V3.0")
        self.running = True
        self.performance_monitor.start_session()

        try:
            # Affichage intro
            self._display_game_intro()

            # Game loop principal
            while self.running:
                loop_start = time.perf_counter()

                # 1. Affichage √©tat actuel
                self._display_current_state()

                # 2. Tour NPC (action IA)
                npc_action = self._process_npc_turn()
                if npc_action:
                    # CORRIG√â - Affichage texte riche au lieu de tuple debug
                    print(f"\n{npc_action['description']}")

                    # Affichage message adaptation IA si pr√©sent
                    if npc_action.get('adaptation_message'):
                        print(f"üí≠ {npc_action['adaptation_message']}")

                # 3. Input joueur
                player_input = self._get_player_input()

                # 4. Traitement input
                if not self._process_player_input(player_input):
                    continue  # Input invalide, recommencer

                # 5. Update de tous les systems
                self._update_systems()

                # 6. Check escalation automatique INT√âGR√â
                if self.config['gameplay']['auto_escalation']:
                    self._check_auto_escalation()

                # 7. Check conditions de fin
                end_condition = self._check_end_conditions()
                if end_condition:
                    self._handle_game_end(end_condition)
                    break

                # 8. Nettoyage et optimisations
                self._cleanup_turn()

                # 9. Performance tracking
                loop_end = time.perf_counter()
                loop_time = (loop_end - loop_start) * 1000  # ms
                self.performance_monitor.record_loop_time(loop_time)

                # Check performance - pas critique mais informatif
                if loop_time > self.config["performance"]["target_response_ms"] * 2:
                    self.logger.warning(f"Performance lente: {loop_time:.1f}ms")

                self.game_state.advance_turn()

        except KeyboardInterrupt:
            self.logger.info("Jeu interrompu par l'utilisateur")
            print("\n\n‚ö†Ô∏è Jeu interrompu...")
        except Exception as e:
            self.logger.error(f"Erreur critique game loop: {e}")
            print(f"\n‚ùå Erreur critique: {e}")
        finally:
            self._cleanup_session()

    def _process_npc_turn(self) -> Optional[Dict[str, Any]]:
        """Traite le tour du NPC avec IA adaptative OPTIMIS√âE"""
        # Contexte pour IA
        context = {
            "location": self.current_environment.location,
            "privacy_level": self.current_environment.privacy_level,
            "turn_count": self.game_state.turn_count,
            "last_action": getattr(self, '_last_npc_action', None),
            "last_success": getattr(self, '_last_action_success', False)
        }

        # IA choisit action
        chosen_action = self.npc.choose_next_action(
            self.player.get_resistance_level(),
            context
        )

        # CORRIG√â - R√©cup√©ration syst√®me dialogue pour g√©n√©ration texte RICHE
        dialogue_system = self.system_manager.get_system("DialogueSystem")
        if dialogue_system:
            description = dialogue_system.generate_npc_action_text(
                chosen_action,
                self.player,
                self.current_environment
            )

            # Message adaptation IA selon contexte
            adaptation_message = None
            if self.game_state.turn_count % 3 == 0:  # Periodiquement
                if context.get('last_success', False):
                    adaptation_message = dialogue_system.generate_adaptation_message("escalating")
                else:
                    adaptation_message = dialogue_system.generate_adaptation_message("becoming_patient")
        else:
            description = f"Il {chosen_action}."
            adaptation_message = None

        # Application des effets
        effects = self._apply_npc_action_effects(chosen_action)

        # Sauvegarde pour contexte suivant
        self._last_npc_action = chosen_action
        self._last_action_success = effects.get('success', False)

        return {
            'action': chosen_action,
            'description': description,
            'adaptation_message': adaptation_message,
            'effects': effects
        }

    def _apply_npc_action_effects(self, action: str) -> Dict[str, Any]:
        """Applique les effets d'une action NPC - OPTIMIS√â"""
        # R√©cup√©ration syst√®me stats
        stats_system = self.system_manager.get_system("StatsSystem")
        if not stats_system:
            return {"success": False, "error": "StatsSystem non trouv√©"}

        # Application des effets sur les stats joueur
        effects = stats_system.apply_npc_action(
            self.player,
            action,
            {
                "location": self.current_environment.location,
                "privacy": self.current_environment.privacy_level
            }
        )

        # Enregistrement pour analytics
        self.game_state.record_npc_action(
            action,
            effects.get('success', False),
            effects.get('escalation_level', 1)
        )

        return effects

    def _check_auto_escalation(self):
        """INT√âGR√â - V√©rification escalation automatique entre lieux"""
        player_summary = self.player.get_current_state_summary()
        current_loc = self.current_environment.location

        # Transition bar ‚Üí voiture si excitation suffisante et volont√© OK
        if (current_loc == "bar" and 
            player_summary["arousal"] > 0.3 and 
            player_summary["resistance"] < 0.8):
            print("\nüöó >>> Il te propose de continuer dans sa voiture...")
            print("'Que dirais-tu d'aller faire un tour ? Il fait si beau ce soir...'")
            self.current_environment = self.environments["voiture"]
            self.game_state.change_location("voiture")
            return

        # Transition voiture ‚Üí salon  
        elif (current_loc == "voiture" and
              player_summary["arousal"] > 0.6 and
              player_summary["resistance"] < 0.6):
            print("\nüè† >>> Il t'emm√®ne √† son appartement...")
            print("'J'habite juste l√†, viens prendre un dernier verre chez moi.'")
            self.current_environment = self.environments["salon"]
            self.game_state.change_location("salon")
            return

        # Transition salon ‚Üí chambre
        elif (current_loc == "salon" and
              player_summary["arousal"] > 0.8 and
              player_summary["resistance"] < 0.4):
            print("\nüõèÔ∏è >>> Il te guide vers sa chambre...")
            print("'Viens, nous serons plus... confortables dans ma chambre.'")
            self.current_environment = self.environments["chambre"]
            self.game_state.change_location("chambre")
            return

    def _get_player_input(self) -> str:
        """R√©cup√®re et valide l'input joueur"""
        # Affichage choix rapides
        print("\nüí≠ Actions rapides:")
        print("  r = r√©sister  |  a = permettre  |  f = fuir  |  aide = commandes")

        # Input avec gestion erreurs
        try:
            player_input = input("\n> ").strip()

            # Cache pour √©viter r√©p√©titions
            if player_input in self._input_cache:
                cache_count = self._input_cache[player_input]
                self._input_cache[player_input] = cache_count + 1
                if cache_count > 3:
                    print("üí° Vous r√©p√©tez souvent cette action. Essayez autre chose ?")
            else:
                self._input_cache[player_input] = 1

            return player_input
        except (EOFError, KeyboardInterrupt):
            return "quit"

    def _process_player_input(self, raw_input: str) -> bool:
        """Traite l'input joueur avec toutes les corrections int√©gr√©es"""
        if not raw_input:
            return False

        # R√©cup√©ration syst√®me input
        input_system = self.system_manager.get_system("InputSystem")
        if not input_system:
            print("‚ùå Syst√®me input non disponible")
            return False

        # Parse et validation
        parsed_input = input_system.parse_input(raw_input)
        if parsed_input["type"] == "invalid":
            print(f"‚ùì Commande non reconnue: '{raw_input}'. Tapez 'aide' pour voir les options.")
            return False

        # Traitement selon type
        if parsed_input["type"] == "command":
            return self._handle_player_command(parsed_input["value"])
        elif parsed_input["type"] == "choice":
            return self._handle_player_choice(parsed_input["value"])
        elif parsed_input["type"] == "quit":
            self.running = False
            return True

        return True

    def _handle_player_command(self, command: str) -> bool:
        """G√®re les commandes joueur - SIGNATURE CORRIG√âE"""
        if command in ["aide", "help"]:
            self._display_help()
            return False  # Pas de tour consomm√©
        elif command in ["resist", "r√©sister"]:
            return self._player_resist_action()
        elif command in ["allow", "permettre"]:
            return self._player_allow_action()
        elif command in ["flee", "fuir"]:
            return self._player_flee_action()
        elif command in ["look", "regarder"]:
            self._display_detailed_state()
            return False  # Pas de tour consomm√©
        elif command == "stats":
            self._display_detailed_stats()
            return False
        elif command == "quit":
            self.running = False
            return True

        return False

    def _player_resist_action(self) -> bool:
        """Traite une action de r√©sistance du joueur - SIGNATURE CORRIG√âE"""
        # R√©cup√©ration syst√®me stats
        stats_system = self.system_manager.get_system("StatsSystem")
        if not stats_system:
            return False

        # Tentative r√©sistance avec signature CORRIG√âE
        resistance_result = stats_system.apply_player_resistance(
            self.player,
            "soft_resistance",
            {
                "location": self.current_environment.location,
                "privacy": getattr(self.current_environment, 'privacy_level', 0.5)
            }
        )

        if resistance_result.get("success", False):
            print("Tu essaies de r√©sister doucement √† ses avances...")
            if resistance_result.get("volonte_gained", 0) > 0:
                print("üí™ Tu te sens un peu plus forte.")
        else:
            print("Tu n'arrives plus √† r√©sister efficacement...")

        # Enregistrement
        self.game_state.record_player_action(
            "resist",
            resistance_result.get("success", False),
            resistance_result.get("stats_before", {}),
            resistance_result.get("stats_after", {})
        )

        return True

    def _player_allow_action(self) -> bool:
        """Traite une action permissive du joueur"""
        print("Tu laisses faire, sans r√©sister...")

        # Pas d'effets directs, mais influence l'IA NPC
        self.game_state.record_player_action(
            "allow", True, {}, {}
        )

        return True

    def _player_flee_action(self) -> bool:
        """Traite une tentative de fuite - OPTIMIS√âE"""
        # Calcul chance de succ√®s selon lieu et stats
        base_chance = 1.0 - self.current_environment.escape_difficulty

        # Modificateur selon volont√©
        willpower_modifier = self.player.get_resistance_level() * 0.3

        # Chance finale
        success_chance = min(0.9, base_chance + willpower_modifier)

        import random
        success = random.random() < success_chance

        if success:
            print("‚úÖ Tu r√©ussis √† t'√©chapper!")
            self.game_state.add_story_flag("escape_successful")
            self.running = False
        else:
            print("‚ùå Tu n'arrives pas √† partir. Il te retient gentiment...")

        self.game_state.record_player_action("flee", success, {}, {})
        self.game_state.unlock_achievement("escape_attempted")

        return True

    def _display_game_intro(self):
        """Affiche l'introduction du jeu"""
        print("\n" + "="*60)
        print(f"üî• {self.config['game']['title'].upper()} üî•")
        print("="*60)
        print("\nVous √™tes dans un bar √©l√©gant. Un homme charmant s'approche de vous...")
        print("üí° Tapez 'aide' √† tout moment pour voir les commandes")
        print()

    def _display_current_state(self):
        """Affiche l'√©tat actuel du jeu - OPTIMIS√â"""
        print("\n" + "-"*60)

        # Informations lieu
        print(f"üìç LIEU: {self.current_environment.display_name}")

        # Stats joueur - utilisation syst√®me stats pour affichage
        stats_system = self.system_manager.get_system("StatsSystem")
        if stats_system:
            stats_display = stats_system.get_stats_display_text(self.player)
            print(f"üí™ VOLONT√â: {stats_display['volonte']}  üî• EXCITATION: {stats_display['excitation']}")

            # Affichage status si pr√©sent
            if stats_display.get('has_status', False):
                print(f"üí´ √âTAT: {stats_display['status']}")

        # √âtat v√™tements si modifi√©
        player_summary = self.player.get_current_state_summary()
        if player_summary.get('exposure', 0) > 0:
            clothing_desc = " | ".join(player_summary.get('clothing', []))
            print(f"üëó TENUE: {clothing_desc}")

        # Informations debug si activ√©es
        if self.config['game']['debug_mode']:
            npc_state = self.npc.get_behavioral_state()
            print(f"ü§ñ DEBUG NPC: {npc_state.get('current_strategy', 'N/A')} "
                  f"(succ√®s: {npc_state.get('success_rate', 0):.0%})")

        print("-"*60)

    def _display_help(self):
        """Affiche l'aide compl√®te"""
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üÜò AIDE - COMMANDES V3.0                                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë ACTIONS PRINCIPALES:                                     ‚ïë
‚ïë ‚Ä¢ r, r√©sister ‚Üí R√©sister √† l'action NPC                 ‚ïë
‚ïë ‚Ä¢ a, permettre ‚Üí Laisser faire l'action                 ‚ïë
‚ïë ‚Ä¢ f, fuir ‚Üí Tenter de quitter la situation              ‚ïë
‚ïë                                                          ‚ïë
‚ïë INFORMATIONS:                                            ‚ïë
‚ïë ‚Ä¢ regarder ‚Üí Observer l'environnement                   ‚ïë
‚ïë ‚Ä¢ stats ‚Üí Voir statistiques d√©taill√©es                  ‚ïë
‚ïë ‚Ä¢ aide ‚Üí Afficher cette aide                            ‚ïë
‚ïë                                                          ‚ïë
‚ïë SYST√àME:                                                 ‚ïë
‚ïë ‚Ä¢ quit ‚Üí Quitter le jeu                                 ‚ïë
‚ïë                                                          ‚ïë
‚ïë NOUVEAUT√âS V3.0:                                        ‚ïë
‚ïë ‚Ä¢ Dialogues riches contextuels                          ‚ïë
‚ïë ‚Ä¢ Escalation automatique entre lieux                    ‚ïë
‚ïë ‚Ä¢ IA adaptive avec feedback visible                     ‚ïë
‚ïë ‚Ä¢ Performance optimis√©e <50ms                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)

    def _update_systems(self):
        """Met √† jour tous les systems"""
        # Calcul delta time
        current_time = time.perf_counter()
        delta_time = current_time - self.last_update_time
        self.last_update_time = current_time

        # Contexte global pour systems
        context = {
            "player": self.player,
            "npc": self.npc,
            "environment": self.current_environment,
            "game_state": self.game_state,
            "config": self.config
        }

        # Update tous les systems
        try:
            self.system_manager.update_all(self.entities, delta_time, **context)
        except Exception as e:
            self.logger.error(f"Erreur update systems: {e}")
            self.game_state.debug_info["error_count"] += 1

    def _check_end_conditions(self) -> Optional[str]:
        """V√©rifie les conditions de fin de partie"""
        return self.game_state.check_end_conditions()

    def _handle_game_end(self, end_type: str):
        """G√®re la fin de partie - ENRICHIE"""
        print("\n" + "="*60)
        if end_type == "submission_complete":
            print("üî• FIN: CESSION TOTALE")
            print("Tu ne peux plus r√©sister √† ses avances...")
        elif end_type == "resistance_victory":
            print("üí™ FIN: R√âSISTANCE VICTORIEUSE")
            print("Tu as r√©ussi √† maintenir tes limites malgr√© ses efforts.")
        elif end_type == "escape_success":
            print("üèÉ‚Äç‚ôÄÔ∏è FIN: FUITE R√âUSSIE")
            print("Tu as r√©ussi √† t'√©chapper de la situation.")
        elif end_type == "time_limit":
            print("‚è∞ FIN: LIMITE DE TEMPS")
            print("La soir√©e se termine...")
        elif end_type == "max_escalation":
            print("üåü FIN: ESCALATION MAXIMALE")
            print("Vous avez atteint l'intimit√© maximale...")
        print("="*60)

        # Affichage statistiques finales
        self._display_final_statistics()

    def _display_final_statistics(self):
        """Affiche les statistiques finales - ENRICHIES"""
        session_summary = self.game_state.get_session_summary()
        print("\nüìä STATISTIQUES FINALES:")
        print("-"*40)
        print(f"‚è±Ô∏è  Dur√©e: {session_summary['session_info']['duration_seconds']//60:.0f} min")
        print(f"üéÆ Tours jou√©s: {session_summary['session_info']['turns']}")
        print(f"üìç Lieux visit√©s: {session_summary['progression']['locations_visited']}/4")
        print(f"üèÜ Achievements: {session_summary['achievements']['unlocked']}/{session_summary['achievements']['total']}")

        # Performance V3.0
        perf_stats = self.performance_monitor.get_session_stats()
        print(f"üíæ M√©moire max: {perf_stats.get('max_memory_mb', 0):.1f} MB")
        print(f"‚ö° Temps moyen: {perf_stats.get('avg_response_ms', 0):.0f} ms")

        # Stats dialogue syst√®me
        dialogue_system = self.system_manager.get_system("DialogueSystem")
        if dialogue_system:
            cache_stats = dialogue_system.get_cache_stats()
            print(f"üó£Ô∏è Cache dialogues: {cache_stats['hit_rate']:.1%} hit rate")

    def _cleanup_turn(self):
        """Nettoyage fin de tour"""
        # Limite cache input pour m√©moire
        if len(self._input_cache) > 50:
            # Garde seulement les 30 plus r√©cents
            items = list(self._input_cache.items())
            self._input_cache = dict(items[-30:])

    def _cleanup_session(self):
        """Nettoyage fin de session"""
        try:
            # Statistiques finales monitoring
            self.performance_monitor.end_session()

            # Log session summary
            summary = self.game_state.get_session_summary()
            self.logger.info(f"Session V3.0 termin√©e: {summary}")
        except Exception as e:
            self.logger.error(f"Erreur cleanup session: {e}")

        print("\nüëã Merci d'avoir jou√© Strip, Sex & Seduce V3.0 !")

    def _display_detailed_state(self):
        """Affiche √©tat d√©taill√© pour debug"""
        if not self.config['game']['debug_mode']:
            print("Mode debug non activ√©")
            return

        print("\nüîç √âTAT D√âTAILL√â V3.0:")
        print(f"Player: {self.player}")
        print(f"NPC: {self.npc}")
        print(f"Environment: {self.current_environment}")
        print(f"Game State: {self.game_state}")

    def _display_detailed_stats(self):
        """Affiche statistiques d√©taill√©es"""
        summary = self.game_state.get_session_summary()
        print("\nüìà STATISTIQUES D√âTAILL√âES V3.0:")
        for section, data in summary.items():
            print(f"\n{section.upper()}:")
            if isinstance(data, dict):
                for key, value in data.items():
                    print(f"  {key}: {value}")
            else:
                print(f"  {data}")

        # Ajout stats systems
        dialogue_system = self.system_manager.get_system("DialogueSystem")
        if dialogue_system:
            cache_stats = dialogue_system.get_cache_stats()
            print(f"\nDIALOGUE SYSTEM PERFORMANCE:")
            for key, value in cache_stats.items():
                print(f"  {key}: {value}")

    def __repr__(self) -> str:
        return (f"GameSession V3.0 (running={self.running}, "
                f"turn={self.game_state.turn_count}, "
                f"location={self.current_environment.location})")
